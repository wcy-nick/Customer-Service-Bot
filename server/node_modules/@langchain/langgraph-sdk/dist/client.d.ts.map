{"version":3,"file":"client.d.ts","names":["Assistant","AssistantGraph","AssistantSortBy","AssistantSelectField","AssistantVersion","CancelAction","Checkpoint","Config","Cron","CronSelectField","CronCreateForThreadResponse","CronCreateResponse","CronSortBy","DefaultValues","GraphSchema","Item","ListNamespaceResponse","Metadata","Run","RunSelectField","RunStatus","SearchItemsResponse","SortOrder","Subgraphs","Thread","ThreadSelectField","ThreadSortBy","ThreadState","ThreadStatus","ThreadValuesFilter","Command","CronsCreatePayload","OnConflictBehavior","RunsCreatePayload","RunsStreamPayload","RunsWaitPayload","StreamEvent","StreamMode","ThreadStreamMode","TypedAsyncGenerator","AsyncCaller","AsyncCallerParams","HeaderValue","getApiKey","RequestHook","URL","RequestInit","Promise","ClientConfig","Record","BaseClient","AbortSignal","T","Response","CronsClient","AssistantsClient","ThreadsClient","TStateType","ValuesType","Array","TUpdateType","Pick","Omit","Partial","AsyncGenerator","RunsClient","TStreamMode","TSubgraphs","TCustomEventType","StoreClient","UiClient","Client","getClientConfigHash"],"sources":["../src/client.d.ts"],"sourcesContent":["import { Assistant, AssistantGraph, AssistantSortBy, AssistantSelectField, AssistantVersion, CancelAction, Checkpoint, Config, Cron, CronSelectField, CronCreateForThreadResponse, CronCreateResponse, CronSortBy, DefaultValues, GraphSchema, Item, ListNamespaceResponse, Metadata, Run, RunSelectField, RunStatus, SearchItemsResponse, SortOrder, Subgraphs, Thread, ThreadSelectField, ThreadSortBy, ThreadState, ThreadStatus, ThreadValuesFilter } from \"./schema.js\";\nimport type { Command, CronsCreatePayload, OnConflictBehavior, RunsCreatePayload, RunsStreamPayload, RunsWaitPayload, StreamEvent } from \"./types.js\";\nimport type { StreamMode, ThreadStreamMode, TypedAsyncGenerator } from \"./types.stream.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\ntype HeaderValue = string | undefined | null;\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nexport declare function getApiKey(apiKey?: string): string | undefined;\nexport type RequestHook = (url: URL, init: RequestInit) => Promise<RequestInit> | RequestInit;\nexport interface ClientConfig {\n    apiUrl?: string;\n    apiKey?: string;\n    callerOptions?: AsyncCallerParams;\n    timeoutMs?: number;\n    defaultHeaders?: Record<string, HeaderValue>;\n    onRequest?: RequestHook;\n}\ndeclare class BaseClient {\n    protected asyncCaller: AsyncCaller;\n    protected timeoutMs: number | undefined;\n    protected apiUrl: string;\n    protected defaultHeaders: Record<string, HeaderValue>;\n    protected onRequest?: RequestHook;\n    constructor(config?: ClientConfig);\n    protected prepareFetchOptions(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        withResponse?: boolean;\n    }): [url: URL, init: RequestInit];\n    protected fetch<T>(path: string, options: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal?: AbortSignal;\n        withResponse: true;\n    }): Promise<[T, Response]>;\n    protected fetch<T>(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal?: AbortSignal;\n        withResponse?: false;\n    }): Promise<T>;\n}\nexport declare class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    createForThread(threadId: string, assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateForThreadResponse>;\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    create(assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateResponse>;\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    delete(cronId: string): Promise<void>;\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    search(query?: {\n        assistantId?: string;\n        threadId?: string;\n        limit?: number;\n        offset?: number;\n        sortBy?: CronSortBy;\n        sortOrder?: SortOrder;\n        select?: CronSelectField[];\n    }): Promise<Cron[]>;\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    count(query?: {\n        assistantId?: string;\n        threadId?: string;\n    }): Promise<number>;\n}\nexport declare class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    get(assistantId: string): Promise<Assistant>;\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    getGraph(assistantId: string, options?: {\n        xray?: boolean | number;\n    }): Promise<AssistantGraph>;\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    getSchemas(assistantId: string): Promise<GraphSchema>;\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    getSubgraphs(assistantId: string, options?: {\n        namespace?: string;\n        recurse?: boolean;\n    }): Promise<Subgraphs>;\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    create(payload: {\n        graphId: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        assistantId?: string;\n        ifExists?: OnConflictBehavior;\n        name?: string;\n        description?: string;\n    }): Promise<Assistant>;\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    update(assistantId: string, payload: {\n        graphId?: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        name?: string;\n        description?: string;\n    }): Promise<Assistant>;\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    delete(assistantId: string): Promise<void>;\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    search(query?: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n    }): Promise<Assistant[]>;\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    count(query?: {\n        metadata?: Metadata;\n        graphId?: string;\n    }): Promise<number>;\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    getVersions(assistantId: string, payload?: {\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n    }): Promise<AssistantVersion[]>;\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    setLatest(assistantId: string, version: number): Promise<Assistant>;\n}\nexport declare class ThreadsClient<TStateType = DefaultValues, TUpdateType = TStateType> extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    get<ValuesType = TStateType>(threadId: string): Promise<Thread<ValuesType>>;\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    create(payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * ID of the thread to create.\n         *\n         * If not provided, a random UUID will be generated.\n         */\n        threadId?: string;\n        /**\n         * How to handle duplicate creation.\n         *\n         * @default \"raise\"\n         */\n        ifExists?: OnConflictBehavior;\n        /**\n         * Graph ID to associate with the thread.\n         */\n        graphId?: string;\n        /**\n         * Apply a list of supersteps when creating a thread, each containing a sequence of updates.\n         *\n         * Used for copying a thread between deployments.\n         */\n        supersteps?: Array<{\n            updates: Array<{\n                values: unknown;\n                command?: Command;\n                asNode: string;\n            }>;\n        }>;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    copy(threadId: string): Promise<Thread<TStateType>>;\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    update(threadId: string, payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n    }): Promise<Thread>;\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    delete(threadId: string): Promise<void>;\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    search<ValuesType = TStateType>(query?: {\n        /**\n         * Metadata to filter threads by.\n         */\n        metadata?: Metadata;\n        /**\n         * Filter by specific thread IDs.\n         */\n        ids?: string[];\n        /**\n         * Maximum number of threads to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         */\n        offset?: number;\n        /**\n         * Thread status to filter on.\n         */\n        status?: ThreadStatus;\n        /**\n         * Sort by.\n         */\n        sortBy?: ThreadSortBy;\n        /**\n         * Sort order.\n         * Must be one of 'asc' or 'desc'.\n         */\n        sortOrder?: SortOrder;\n        /**\n         * Array of fields to select.\n         * Elements or array must be one of 'thread_id, 'created_at', 'updated_at', 'metadata', 'config', 'context', 'status', 'values', or 'interrupts'.\n         */\n        select?: ThreadSelectField[];\n        /**\n         * Values to filter threads by.\n         */\n        values?: ThreadValuesFilter;\n    }): Promise<Thread<ValuesType>[]>;\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    count<ValuesType = TStateType>(query?: {\n        metadata?: Metadata;\n        values?: ValuesType;\n        status?: ThreadStatus;\n    }): Promise<number>;\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    getState<ValuesType = TStateType>(threadId: string, checkpoint?: Checkpoint | string, options?: {\n        subgraphs?: boolean;\n    }): Promise<ThreadState<ValuesType>>;\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    updateState<ValuesType = TUpdateType>(threadId: string, options: {\n        values: ValuesType;\n        checkpoint?: Checkpoint;\n        checkpointId?: string;\n        asNode?: string;\n    }): Promise<Pick<Config, \"configurable\">>;\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    patchState(threadIdOrConfig: string | Config, metadata: Metadata): Promise<void>;\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    getHistory<ValuesType = TStateType>(threadId: string, options?: {\n        limit?: number;\n        before?: Config;\n        checkpoint?: Partial<Omit<Checkpoint, \"thread_id\">>;\n        metadata?: Metadata;\n    }): Promise<ThreadState<ValuesType>[]>;\n    joinStream(threadId: string, options?: {\n        lastEventId?: string;\n        streamMode?: ThreadStreamMode | ThreadStreamMode[];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n}\nexport declare class RunsClient<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> extends BaseClient {\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: null, assistantId: string, payload?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"multitaskStrategy\" | \"onCompletion\">): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: string, assistantId: string, payload?: RunsStreamPayload<TStreamMode, TSubgraphs>): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    create(threadId: string | null, assistantId: string, payload?: RunsCreatePayload): Promise<Run>;\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    createBatch(payloads: (RunsCreatePayload & {\n        assistantId: string;\n    })[]): Promise<Run[]>;\n    wait(threadId: null, assistantId: string, payload?: Omit<RunsWaitPayload, \"multitaskStrategy\" | \"onCompletion\">): Promise<ThreadState[\"values\"]>;\n    wait(threadId: string, assistantId: string, payload?: RunsWaitPayload): Promise<ThreadState[\"values\"]>;\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    list(threadId: string, options?: {\n        /**\n         * Maximum number of runs to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         * Defaults to 0.\n         */\n        offset?: number;\n        /**\n         * Status of the run to filter by.\n         */\n        status?: RunStatus;\n        select?: RunSelectField[];\n    }): Promise<Run[]>;\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    get(threadId: string, runId: string): Promise<Run>;\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    cancel(threadId: string, runId: string, wait?: boolean, action?: CancelAction): Promise<void>;\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    join(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<TStateType>;\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    joinStream(threadId: string | undefined | null, runId: string, options?: {\n        signal?: AbortSignal;\n        cancelOnDisconnect?: boolean;\n        lastEventId?: string;\n        streamMode?: StreamMode | StreamMode[];\n    } | AbortSignal\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    delete(threadId: string, runId: string): Promise<void>;\n}\nexport declare class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    putItem(namespace: string[], key: string, value: Record<string, unknown>, options?: {\n        index?: false | string[] | null;\n        ttl?: number | null;\n    }): Promise<void>;\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    getItem(namespace: string[], key: string, options?: {\n        refreshTtl?: boolean | null;\n    }): Promise<Item | null>;\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    deleteItem(namespace: string[], key: string): Promise<void>;\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    searchItems(namespacePrefix: string[], options?: {\n        filter?: Record<string, unknown>;\n        limit?: number;\n        offset?: number;\n        query?: string;\n        refreshTtl?: boolean | null;\n    }): Promise<SearchItemsResponse>;\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    listNamespaces(options?: {\n        prefix?: string[];\n        suffix?: string[];\n        maxDepth?: number;\n        limit?: number;\n        offset?: number;\n    }): Promise<ListNamespaceResponse>;\n}\ndeclare class UiClient extends BaseClient {\n    private static promiseCache;\n    private static getOrCached;\n    getComponent(assistantId: string, agentName: string): Promise<string>;\n}\nexport declare class Client<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> {\n    /**\n     * The client for interacting with assistants.\n     */\n    assistants: AssistantsClient;\n    /**\n     * The client for interacting with threads.\n     */\n    threads: ThreadsClient<TStateType, TUpdateType>;\n    /**\n     * The client for interacting with runs.\n     */\n    runs: RunsClient<TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * The client for interacting with cron runs.\n     */\n    crons: CronsClient;\n    /**\n     * The client for interacting with the KV store.\n     */\n    store: StoreClient;\n    /**\n     * The client for interacting with the UI.\n     * @internal Used by LoadExternalComponent and the API might change in the future.\n     */\n    \"~ui\": UiClient;\n    /**\n     * @internal Used to obtain a stable key representing the client.\n     */\n    private \"~configHash\";\n    constructor(config?: ClientConfig);\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport declare function getClientConfigHash(client: Client): string | undefined;\nexport {};\n"],"mappings":";;;;;;KAIK0C,WAAAA;;AADoE;AAazE;AACA;;;;;;;;AACiBM,iBAFOL,SAAAA,CAEK,MAAA,CAAA,EAAA,MAAA,CAAA,EAAA,MAAA,GAAA,SAAA;AAAA,KADjBC,WAAAA,GACiB,CAAA,GAAA,EADGC,GACH,EAAA,IAAA,EADcC,WACd,EAAA,GAD8BC,OAC9B,CADsCD,WACtC,CAAA,GADqDA,WACrD;AAGTL,UAHHO,YAAAA,CAGGP;QAEgBC,CAAAA,EAAAA,MAAAA;QAAfO,CAAAA,EAAAA,MAAAA;eACLL,CAAAA,EAHIH,iBAGJG;;EAEFM,cAAU,CAAA,EAHHD,MAGG,CAAA,MAAA,EAHYP,WAGZ,CAAA;EAAA,SAAA,CAAA,EAFRE,WAEQ;;cAAVM,UAAAA,CAI+BR;YAAfO,WAAAA,EAHHT,WAGGS;YACJL,SAAAA,EAAAA,MAAAA,GAAAA,SAAAA;YACDI,MAAAA,EAAAA,MAAAA;YACiCF,cAAAA,EAH5BG,MAG4BH,CAAAA,MAAAA,EAHbJ,WAGaI,CAAAA;YAEzCG,SAAAA,CAAAA,EAJSL,WAITK;aAGHJ,CAAAA,MAAAA,CAAAA,EANWG,YAMXH;YAAWC,mBAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EALiCA,WAKjCA,GAAAA;IACqBA,IAAAA,CAAAA,EAAAA,OAAAA;IAE7BG,MAAAA,CAAAA,EANAA,MAMAA,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA;IAEAE,SAAAA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;IAEAC,YAAAA,CAAAA,EAAAA,OAAAA;MAAGC,CAAAA,GAAAA,EAPNR,GAOMQ,EAAAA,IAAAA,EAPKP,WAOLO,CAAAA;YAAZN,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EANsCD,WAMtCC,GAAAA;IACuCD,IAAAA,CAAAA,EAAAA,OAAAA;IAE9BG,MAAAA,CAAAA,EAPAA,MAOAA,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA;IAEAE,SAAAA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;IAEDC,MAAAA,CAAAA,EATCD,WASDC;IAARL,YAAAA,EAAAA,IAAAA;MAPAA,SAASK,GAAGC;EASCC,UAAAA,KAAW,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,MAAA,EAAA,QAAA,EAReR,WAQf,GAAA;IAAA,IAAA,CAAA,EAAA,OAAA;IAQqCf,MAAAA,CAAAA,EAdpDkB,MAcoDlB,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA;IAA6BrB,SAAAA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;IAARqC,MAAAA,CAAAA,EAZzEI,WAYyEJ;IAOhDhB,YAAAA,CAAAA,EAAAA,KAAAA;MAjBlCgB,OAiB+DpC,CAjBvDyC,CAiBuDzC,CAAAA;;AAK3CoC,cApBPO,WAAAA,SAAoBJ,UAAAA,CAoBbH;;;;;;;;mEAZyChB,qBAAqBgB,QAAQrC;EAuC7E6C;;;;;;QAsBwBzC,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EAtDHiB,kBAsDGjB,CAAAA,EAtDkBiC,OAsDlBjC,CAtD0BH,kBAsD1BG,CAAAA;;;;;QAqB1BG,CAAAA,MAAAA,EAAAA,MAAAA,CAAAA,EAtES8B,OAsET9B,CAAAA,IAAAA,CAAAA;;;;;;QAmBHjB,CAAAA,MAAAA,EAAAA;IAAR+C,WAAAA,CAAAA,EAAAA,MAAAA;IAMyBA,QAAAA,CAAAA,EAAAA,MAAAA;IASd9B,KAAAA,CAAAA,EAAAA,MAAAA;IAGFf,MAAAA,CAAAA,EAAAA,MAAAA;IACGoB,MAAAA,CAAAA,EAjGHV,UAiGGU;IACHnB,SAAAA,CAAAA,EAjGGmB,SAiGHnB;IACDH,MAAAA,CAAAA,EAjGCS,eAiGDT,EAAAA;MAhGR+C,OAgGAA,CAhGQvC,IAgGRuC,EAAAA,CAAAA;;;;;;;;OAnFsCG,CAAAA,KAmHZ,CAnHYA,EAAAA;;IAmHzBM,QAAAA,CAAAA,EAAAA,MAAa;EAAA,CAAA,CAAA,EArH1BT,OAqH0B,CAAA,MAAA,CAAA;;AAA2CU,cAnHxDF,gBAAAA,SAAyBL,UAAAA,CAmH+BO;;;;;;;KA2CnD3B,CAAAA,WAAAA,EAAAA,MAAAA,CAAAA,EAvJIiB,OAuJJjB,CAvJY9B,SAuJZ8B,CAAAA;;;;;;;UAmBUN,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IAARuB,IAAAA,CAAAA,EAAAA,OAAAA,GAAAA,MAAAA;MAjKpBA,OA6KW9B,CA7KHhB,cA6KGgB,CAAAA;;;;;;YA4CFW,CAAAA,WAAAA,EAAAA,MAAAA,CAAAA,EAnNoBmB,OAmNpBnB,CAnN4Bd,WAmN5Bc,CAAAA;;;;;;;;cA4BM6B,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IACJxC,SAAAA,CAAAA,EAAAA,MAAAA;IACFyC,OAAAA,CAAAA,EAAAA,OAAAA;MAtOTX,OAuOSnB,CAvODL,SAuOCK,CAAAA;;;;;;QAUTmB,CAAAA,OAAAA,EAAAA;IAOqBa,OAAAA,EAAAA,MAAAA;IACbF,MAAAA,CAAAA,EAjPCnD,MAiPDmD;IACKpD,OAAAA,CAAAA,EAAAA,OAAAA;IAGAC,QAAAA,CAAAA,EAnPFU,QAmPEV;IAALsD,WAAAA,CAAAA,EAAAA,MAAAA;IAARd,QAAAA,CAAAA,EAjPWf,kBAiPXe;IAOkCxC,IAAAA,CAAAA,EAAAA,MAAAA;IAAkBU,WAAAA,CAAAA,EAAAA,MAAAA;MArPpD8B,OAqP+DA,CArPvD/C,SAqPuD+C,CAAAA;;;;;;;QAa3CW,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA;IAAZ/B,OAAAA,CAAAA,EAAAA,MAAAA;IAARoB,MAAAA,CAAAA,EAzPSxC,MAyPTwC;IAGaT,OAAAA,CAAAA,EAAAA,OAAAA;IAAmBA,QAAAA,CAAAA,EA1PrBrB,QA0PqBqB;IAKzBF,IAAAA,CAAAA,EAAAA,MAAAA;IAFR4B,WAAAA,CAAAA,EAAAA,MAAAA;MA1PCjB,OAqDyFG,CArDjFlD,SAqDiFkD,CAAAA;;AA2MjG;;;;QAC+Bb,CAAAA,WAAAA,EAAAA,MAAAA,CAAAA,EA3PEU,OA2PFV,CAAAA,IAAAA,CAAAA;;;;;;QAA2HyB,CAAAA,MAAAA,EAAAA;IAA6GI,OAAAA,CAAAA,EAAAA,MAAAA;IAAaC,IAAAA,CAAAA,EAAAA,MAAAA;IAAYV,QAAAA,CAAAA,EAlP7QxC,QAkP6QwC;IAAYG,KAAAA,CAAAA,EAAAA,MAAAA;IAAaQ,MAAAA,CAAAA,EAAAA,MAAAA;IAAtE7B,MAAAA,CAAAA,EA/OlOrC,eA+OkOqC;IACpNF,SAAAA,CAAAA,EA/OXf,SA+OWe;IAAaA,MAAAA,CAAAA,EA9O3BlC,oBA8O2BkC,EAAAA;MA7OpCU,OA6OmDV,CA7O3CrC,SA6O2CqC,EAAAA,CAAAA;;;;;;;;OAAoN+B,CAAAA,MAAAA,EAAAA;IAAtE7B,QAAAA,CAAAA,EApOtLtB,QAoOsLsB;IAStIN,OAAAA,CAAAA,EAAAA,MAAAA;MA3O3Dc,OA2OuF7B,CAAAA,MAAAA,CAAAA;;;;;;;aAU+BS,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IAARoB,QAAAA,CAAAA,EA7OnG9B,QA6OmG8B;IAC5DZ,KAAAA,CAAAA,EAAAA,MAAAA;IAA0BR,MAAAA,CAAAA,EAAAA,MAAAA;MA3O5EoB,OA2OoEA,CA3O5D3C,gBA2O4D2C,EAAAA,CAAAA;;;;;;;;WA0CQA,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,MAAAA,CAAAA,EA7Q/BA,OA6Q+BA,CA7QvB/C,SA6QuB+C,CAAAA;;AAUpEU,cArRKD,aAqRLC,CAAAA,aArRgC5C,aAqRhC4C,EAAAA,cArR6DA,UAqR7DA,CAAAA,SArRiFP,UAAAA,CAqRjFO;;;;;;;KAsBTO,CAAAA,aApScP,UAoSdO,CAAAA,CAAAA,QAAAA,EAAAA,MAAAA,CAAAA,EApS6CjB,OAoS7CiB,CApSqDxC,MAoSrDwC,CApS4DN,UAoS5DM,CAAAA,CAAAA;;;;AAcP;;;QAwBQjB,CAAAA,QAAAA,EAAAA;IA4BQhC;;;IA8CCkC,QAAAA,CAAAA,EAzYEhC,QAyYFgC;IAKD5B;;;;;;IAmBFiD;;;;;IAKOC,QAAM,CAAA,EA1ZRvC,kBA0ZQ;IAAA;;;IAIXuB,OAAAA,CAAAA,EAAAA,MAAAA;IAIWE;;;;;IAImBW,UAAAA,CAAAA,EA5ZzBT,KA4ZyBS,CAAAA;MAApCH,OAAAA,EA3ZWN,KA2ZXM,CAAAA;QAICX,MAAAA,EAAAA,OAAAA;QAIAe,OAAAA,CAAAA,EAjaevC,OAiafuC;QAKAC,MAAAA,EAAAA,MAAAA;MAKctB,CAAAA,CAAAA;;IAKDwB;;;;;;;;;MAnahBzB,QAAQvB,OAAOiC;;;;;;0BAMKV,QAAQvB,OAAOiC;;;;;;;;;;;;eAYxBxC;;;;;;;;;;MAUX8B,QAAQvB;;;;;;4BAMcuB;;;;;;;sBAONU;;;;eAILxC;;;;;;;;;;;;;;;;;aAiBFW;;;;aAIAF;;;;;gBAKGJ;;;;;aAKHG;;;;aAIAI;MACTkB,QAAQvB,OAAOkC;;;;;;;;;qBASAD;eACJxC;aACFyC;aACA9B;MACTmB;;;;;;;wBAOkBU,2CAA2CnD;;MAE7DyC,QAAQpB,YAAY+B;;;;;;;2BAOCE;YACbF;iBACKpD;;;MAGbyC,QAAQc,KAAKtD;;;;;;;wCAOqBA,kBAAkBU,WAAW8B;;;;;;;;0BAQ3CU;;aAEXlD;iBACIwD,QAAQD,KAAKxD;eACfW;MACX8B,QAAQpB,YAAY+B;;;iBAGPpB,mBAAmBA;;;KAGjC0B;;WAEQ5B;;;;cAIM6B,wBAAwBpD,6BAA6B4C,gDAAgDP,UAAAA;6BAC3Fb,aAAaA,eAAeA,+FAA+FyB,KAAK5B,kBAAkBgC,aAAaC,qDAAqD5B,oBAAoB2B,aAAaC,YAAYV,YAAYG,aAAaQ;6BAC1R/B,aAAaA,eAAeA,iGAAiGH,kBAAkBgC,aAAaC,cAAc5B,oBAAoB2B,aAAaC,YAAYV,YAAYG,aAAaQ;;;;;;;;;iEAS5MnC,oBAAoBc,QAAQ7B;;;;;;;yBAOpEe;;SAEhBc,QAAQ7B;sDACqC4C,KAAK3B,yDAAyDY,QAAQpB;wDACpEQ,kBAAkBY,QAAQpB;;;;;;;;;;;;;;;;;;;;;;aAsBnEP;aACAD;MACT4B,QAAQ7B;;;;;;;;wCAQ0B6B,QAAQ7B;;;;;;;;;;mEAUmBb,eAAe0C;;;;;;;;;aASnEI;MACTJ,QAAQU;;;;;;;;;;;;;;;;aAgBCN;;;iBAGId,aAAaA;MAC1Bc;;KAEDa;;WAEQ5B;;;;;;;;;;2CAU8BW;;cAExBsB,WAAAA,SAAoBnB,UAAAA;;;;;;;;;;;;;;;;;;;;;mDAqBYD;;;MAG7CF;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA4BAA,QAAQhC;;;;;;;;gDAQkCgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAsCjCE;;;;;MAKTF,QAAQ1B;;;;;;;;;;;;;;;;;MAiBR0B,QAAQ/B;;cAEFsD,QAAAA,SAAiBpB,UAAAA;;;wDAG2BH;;cAErCwB,oBAAoB1D,6BAA6B4C;;;;cAItDF;;;;WAIHC,cAAcC,YAAYG;;;;QAI7BK,WAAWR,YAAYG,aAAaQ;;;;SAInCd;;;;SAIAe;;;;;SAKAC;;;;;uBAKctB;;;;;iBAKDwB,mBAAAA,SAA4BD"}